#include <math.h>

//
// Бинаризация числовых данных представляет собой запись их в виде отрезков исходя из оценок информативности.
// То есть сначала необходимо определить структуру данных, описывающую отрезки и лучи.
// Возможно использование INFINITY и -INFINITY для описания лучей.
// 
struct segment_f {
    float start;
    float end;
};

// Функция дискретизации массива значений по соответствию ему класса и функции оценки энтропийной информативности.
void discretize_by_entropy(float* feature_values, int* classes, int rows_count, segment_f* result) {
    // Для разбиения на отрезки надо, по идее, отсортировать все значения. 
    // Попытка интеграции алгоритмов бинаризации и сортировки НЕ ДАСТ прироста в производительности.
    // То есть производительность результирующего алгоритма, вообще говоря, будет НЕ ЛУЧШЕ, чем
    // сортировки и последующей бинаризации по отдельности.

    
    //qsort();
    
    
    segment_f tmp_segment;
    
    int row_index, segment_index;
    row_index = 0;
    
    //tmp_segment.start = -INFINITY;
    //tmp_segment.end = INFINITY;
    while (row_index < rows_count - 1) {
        row_index++;
    }
    
    // Далее выполняем слияние троек сегментов пока информативность 
    // их объединений больше, чем информативность их по отдельности.
    // Возможен ввод ограничения на количество зон разбиения.
    
    
}

// А вот такая структура для описания обучающих данных для классификации:
/*
struct train_data {
    int rows_count;
    int features_count;
    
    char** features_names;
    float** features_data;
    int* classes;
};
 * */